<!DOCTYPE html>
<html lang="pt-BR" class="h-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Papelada - Extração & Avaliação</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Fontes Google para estilo --><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=Bebas+Neue&display=swap" rel="stylesheet">
    <style>
        /* --- Neobrutalist Style Definitions --- */
        body {
            font-family: 'Inter', sans-serif;
            font-weight: 700; /* Bolder by default */
        }

        .neo-card {
            background-color: white;
            border: 4px solid #000;
            /* The signature Neobrutalist shadow */
            box-shadow: 8px 8px 0 0 #000;
            border-radius: 8px;
        }
        
        /* Estilo para o Título PAPELADA (Bebas Neue + Sombra forte) */
        .neo-title {
            font-family: 'Bebas Neue', sans-serif;
            text-shadow: 6px 6px 0 #000; /* Sombra preta MAIS FORTE */
            line-height: 1; /* Tira o espaçamento excessivo da fonte */
        }


        .neo-button {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            font-weight: 900; /* Extra bold */
            text-transform: uppercase;
            border: 4px solid #000;
            box-shadow: 5px 5px 0 0 #000;
            border-radius: 8px;
            transition: all 0.1s ease-in-out;
            cursor: pointer;
            white-space: nowrap; /* Evita quebra de linha nos botões de controle */
        }

        .neo-button:hover, .neo-button:focus {
            /* On hover, "press" the button */
            box-shadow: 2px 2px 0 0 #000;
            transform: translate(3px, 3px);
        }
        
        .neo-button:disabled {
            background-color: #a1a1aa; /* zinc-400 */
            color: #52525b; /* zinc-600 */
            box-shadow: none;
            transform: none;
            cursor: not-allowed;
        }

        .neo-input {
            border: 4px solid #000;
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-weight: 700;
        }
        .neo-input:focus {
            outline: none;
            border-color: #3b82f6; /* blue-500 */
            box-shadow: 0 0 0 4px #3b82f6; /* blue-500 ring */
        }
        
        .neo-radio-label {
            background-color: white;
            border: 4px solid #000;
            box-shadow: 5px 5px 0 0 #000;
            border-radius: 8px;
            padding: 1rem;
            cursor: pointer;
            transition: all 0.1s ease-in-out;
            font-weight: 900;
            text-transform: uppercase;
            text-align: center;
        }
        .neo-radio-label:hover {
            box-shadow: 2px 2px 0 0 #000;
            transform: translate(3px, 3px);
        }
        
        /* Style for the selected radio button's label */
        input[type="radio"]:checked + .neo-radio-label {
            background-color: #bfdbfe; /* blue-200 */
            box-shadow: 2px 2px 0 0 #000;
            transform: translate(3px, 3px);
        }

        .file-input-hidden {
            width: 0.1px;
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }

        /* --- Custom Scrollbar (for terminal) --- */
        #progress-log-container::-webkit-scrollbar {
            width: 12px;
        }
        #progress-log-container::-webkit-scrollbar-track {
            background: #000;
        }
        #progress-log-container::-webkit-scrollbar-thumb {
            background-color: #60a5fa; /* blue-400 */
            border: 2px solid #000;
        }
        
        /* Modal Backdrop */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 50;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
        }
        
        /* Tooltip Container */
        .mode-label-container {
            position: relative;
        }
        
        .mode-tooltip {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            padding: 8px;
            margin-top: 10px;
            background-color: #fff;
            border: 4px solid #000;
            box-shadow: 5px 5px 0 0 #000;
            border-radius: 8px;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            font-size: 0.875rem;
            font-weight: 700;
        }
        
        .mode-tooltip.visible {
            opacity: 1;
            visibility: visible;
        }
        
        /* --- Botão (?) discreto --- */
        .mode-help-btn {
            background-color: transparent;
            color: #000; /* Preto */
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: 900;
            cursor: pointer;
            border: none;
            box-shadow: none;
            line-height: 1;
            transition: all 0.1s;
        }
        
        .mode-help-btn:hover {
            color: #3b82f6; /* Azul no hover */
            transform: scale(1.1); /* Efeito leve */
        }

    </style>
</head>
<body class="bg-slate-100 flex items-center justify-center min-h-screen p-4 text-black">
    
    <!-- TÍTULO E SUBTÍTULO FORA DA CAIXA (NOVO DESIGN DE LOGO) -->
    <div class="absolute top-4 left-1/2 transform -translate-x-1/2 text-center z-40">
        <h1 class="text-8xl text-blue-600 neo-title uppercase">Papelada</h1>
        <p class="text-lg font-bold text-slate-800 -mt-2">Devagar também é Pressa</p>
    </div>
    <!-- FIM TÍTULO/SUBTÍTULO -->

    <div class="bg-white w-full max-w-4xl p-6 sm:p-8 rounded-xl shadow-lg neo-card mt-32 sm:mt-36">
        
        <!-- HEADER INTERNO DA CAIXA -->
        <div class="mb-6 pb-4 border-b-4 border-black">
            <div class="flex justify-between items-start">
                
                <!-- Botão Ajuda (Esquerda) -->
                <button id="help-btn" class="neo-button bg-slate-200 text-sm py-2 px-4">Ajuda</button>

                <!-- Espaço Central Vazio (Títulos foram movidos) -->
                <div class="flex-grow mx-4">
                    <!-- Mantido vazio para espaçamento -->
                </div>

                <!-- Controles (Direita) -->
                <div class="flex space-x-2">
                    
                    <!-- Dropdown Memória (NOVO) -->
                    <div class="relative inline-block text-left" id="memory-dropdown-container">
                        <button type="button" id="memory-dropdown-btn" class="neo-button bg-slate-700 text-white text-sm py-2 px-4">
                            Memória <span class="ml-1">▼</span>
                        </button>
                        <!-- Dropdown Content -->
                        <div id="memory-dropdown-content" class="absolute right-0 mt-2 w-48 rounded-lg shadow-lg bg-white neo-card border-black p-2 hidden z-10 space-y-2" style="box-shadow: 4px 4px 0 0 #000;">
                            <button id="clear-memory-btn" class="neo-button bg-red-600 text-white w-full py-2 px-3 text-sm" style="box-shadow: 2px 2px 0 0 #000;">Limpar Memória</button>
                            <button id="download-memory-btn" class="neo-button bg-slate-600 text-white w-full py-2 px-3 text-sm" style="box-shadow: 2px 2px 0 0 #000;">Baixar Memória</button>
                            <input type="file" id="load-memory-input" accept=".json" class="file-input-hidden">
                            <label for="load-memory-input" class="neo-button bg-green-600 text-white w-full block text-sm py-2 px-3" style="box-shadow: 2px 2px 0 0 #000;">Carregar Memória</label>
                        </div>
                    </div>

                    <!-- Botão Encerrar Sessão -->
                    <button id="logout-btn-top" class="neo-button bg-red-600 text-white text-sm py-2 px-4">Encerrar Sessão</button>
                </div>
            </div>
        </div>
        <!-- FIM HEADER INTERNO -->

        <!-- ÁREA DE MENSAGEM GLOBAL -->
        <div id="message-area" class="text-sm p-4 border-4 border-black rounded-lg hidden mb-4 font-bold"></div>

        <!-- 
          TELA 1: CONFIGURAÇÃO DE SESSÃO 
        -->
        <div id="screen-config" class="space-y-6">
            <h2 class="text-2xl sm:text-3xl font-black uppercase text-center">Configurar Sessão</h2>
            <p class="text-center font-bold">Insira as chaves de API necessárias para operar o sistema.</p>
            
            <!-- VISTA 1: QUICK START (CHAVES SALVAS) -->
            <div id="config-quick-start" class="hidden space-y-6">
                <div class="neo-card bg-slate-50 p-4 space-y-2">
                    <h3 class="text-xl font-black uppercase text-center mb-4">Chaves de API Configuradas</h3>
                    <p class="text-sm"><strong>Papelada API Key:</strong> <span id="status-papelada-key" class="font-bold text-green-600">...</span></p>
                    <p class="text-sm"><strong>OpenAI API Key:</strong> <span id="status-openai-key" class="font-bold text-slate-500">...</span></p>
                </div>
                
                <button id="quick-start-btn" class="neo-button bg-blue-600 text-white w-full">
                    Iniciar Nova Sessão
                </button>
                <button id="show-full-form-btn" class="neo-button bg-slate-200 w-full text-sm">
                    Atualizar Chaves
                </button>
            </div>
            
            <!-- VISTA 2: FULL FORM (CHAVES AUSENTES OU ATUALIZAÇÃO) -->
            <div id="config-full-form" class="hidden space-y-4">
                 <!-- Campo Papelada API Key -->
                <div>
                    <label for="papelada-api-key" class="block text-sm font-black uppercase mb-2">Papelada API Key (X-API-Key)</label>
                    <input type="password" id="papelada-api-key" placeholder="Chave de segurança do backend (Obrigatório)" class="neo-input w-full">
                </div>
                
                <!-- Campo OpenAI API Key -->
                <div>
                    <label for="openai-api-key" class="block text-sm font-black uppercase mb-2">OpenAI API Key (Opcional)</label>
                    <input type="password" id="openai-api-key" placeholder="Sua chave LLM (Substitui a chave do ambiente)" class="neo-input w-full">
                </div>

                <button id="config-save-btn" class="neo-button bg-blue-600 text-white w-full">
                    Salvar e Iniciar
                </button>
                <button id="cancel-full-form-btn" class="neo-button bg-slate-200 w-full text-sm hidden">
                    Cancelar
                </button>
            </div>
            
        </div>

        <!-- 
          TELA 2: UPLOAD E MODO DE EXECUÇÃO
        -->
        <div id="screen-main" class="hidden space-y-8">
            <!-- Este <form> NÃO será submetido; é apenas para layout -->
            <form id="upload-form" class="space-y-6" onsubmit="return false;">
                
                <!-- Seleção de Modo -->
                <div>
                    <h3 class="text-xl font-black uppercase mb-4">1. Modo de Execução</h3>
                    <fieldset>
                        <legend class="sr-only">Escolha o modo de execução</legend>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                            
                            <!-- Papelzinho -->
                            <div class="mode-label-container">
                                <input id="mode-standard" value="standard" name="execution-mode" type="radio" class="hidden peer">
                                <label for="mode-standard" class="neo-radio-label flex justify-between items-center">
                                    Papelzinho
                                    <span class="mode-help-btn ml-2" data-mode="standard">(?)</span>
                                </label>
                                <div class="mode-tooltip" id="tooltip-standard">Papelzinho: O modo mais rápido e barato. Não tenta aprender novas regras de regex, apenas aplica as regras existentes na memória. Uso recomendado para documentos repetitivos com regras já validadas (Warm Start).</div>
                            </div>

                            <!-- Papelada -->
                            <div class="mode-label-container">
                                <input id="mode-smart" value="smart" name="execution-mode" type="radio" class="hidden peer" checked>
                                <label for="mode-smart" class="neo-radio-label flex justify-between items-center">
                                    Papelada
                                    <span class="mode-help-btn ml-2" data-mode="smart">(?)</span>
                                </label>
                                <div class="mode-tooltip" id="tooltip-smart">Papelada (Smart): Modo padrão. Tenta aplicar regras existentes, mas usa o LLM para extrair dados ausentes. Se a extração do LLM for de alta confiança, ele tenta gerar uma nova regra de regex em SEGUNDO PLANO (aprendizado). Recomendado para lotes mistos.</div>
                            </div>
                            
                            <!-- Papelão -->
                            <div class="mode-label-container">
                                <input id="mode-pro" value="pro" name="execution-mode" type="radio" class="hidden peer">
                                <label for="mode-pro" class="neo-radio-label flex justify-between items-center">
                                    Papelão
                                    <span class="mode-help-btn ml-2" data-mode="pro">(?)</span>
                                </label>
                                <div class="mode-tooltip" id="tooltip-pro">Papelão (Pro): Modo estratégico e lento. Agrupa documentos idênticos. O primeiro (Professor) usa LLM e gera regras. Os seguintes (Alunos) usam as regras do professor imediatamente (aprendizado sequencial). Melhor para grandes lotes de documentos similares (Cold Start).</div>
                            </div>
                        </div>
                    </fieldset>
                </div>
                
                <!-- Upload de Ficheiros -->
                <div>
                    <h3 class="text-xl font-black uppercase mb-4">2. Ficheiros</h3>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <!-- Schema -->
                        <div class="text-center">
                            <input type="file" id="schema-file" required accept=".json" class="file-input-hidden">
                            <label for="schema-file" class="neo-button bg-blue-500 text-white w-full block">Carregar Schema</label>
                            <span id="schema-file-name" class="text-xs font-bold mt-2 block truncate"></span>
                        </div>
                        <!-- PDFs -->
                        <div class="text-center">
                            <input type="file" id="pdf-files" required accept=".pdf" multiple class="file-input-hidden">
                            <label for="pdf-files" class="neo-button bg-blue-500 text-white w-full block">Carregar PDFs</label>
                            <span id="pdf-file-names" class="text-xs font-bold mt-2 block"></span>
                        </div>
                        <!-- Referência (Opcional) -->
                        <div class="text-center">
                            <input type="file" id="reference-file" accept=".json" class="file-input-hidden">
                            <label for="reference-file" class="neo-button bg-slate-200 w-full block">Avaliação (Opcional)</label>
                            <span id="reference-file-name" class="text-xs font-bold mt-2 block truncate"></span>
                        </div>
                    </div>
                </div>

                <!-- Botão de Extração -->
                <div class="pt-6">
                    <button type="button" id="extract-btn" class="neo-button bg-blue-600 text-white w-full text-2xl">
                        Iniciar Extração
                    </button>
                </div>
            </form>
            
            <!-- O bloco de Gerenciamento foi movido para o cabeçalho. -->
            
        </div>

        <!-- 
          TELA 3: PROGRESSO (AGORA É REAL-TIME)
        -->
        <div id="screen-progress" class="hidden space-y-6 py-12">
            
            <div class="flex justify-center items-center space-x-3">
                <div class="spinner w-8 h-8 border-4 border-black rounded-full"></div>
                <h2 class="text-2xl sm:text-3xl font-black uppercase">A processar...</h2>
            </div>
            
            <!-- Barra de Progresso -->
            <div>
                <p id="progress-text" class="text-lg font-black text-center mb-2">Processando 0 / 0 arquivos...</p>
                <div class="w-full bg-white border-4 border-black rounded-lg h-8 p-1">
                    <div id="progress-bar" class="bg-blue-500 h-full rounded-sm border-2 border-black" style="width: 0%"></div>
                </div>
            </div>
            
            <!-- Log de Processamento (Terminal) -->
            <div id="progress-log-container" class="w-full h-48 bg-black text-slate-200 text-sm font-mono p-4 rounded-lg border-4 border-black overflow-y-auto">
                <p class="text-neutral-500">A iniciar conexão WebSocket...</p>
                <!-- Log será preenchido aqui -->
            </div>

            <button id="cancel-btn" class="neo-button bg-slate-200 mx-auto block">
                Cancelar
            </button>
        </div>


        <!-- 
          TELA 4: RESULTADOS
        -->
        <div id="screen-results" class="hidden space-y-6">
            <h2 class="text-2xl sm:text-3xl font-black uppercase">Resultados da Extração</h2>
            
            <!-- Secção de Métricas e Avaliação -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <!-- Métricas -->
                <div class="neo-card bg-slate-50 p-4 space-y-2">
                    <h3 class="text-lg font-black uppercase">Métricas de Execução</h3>
                    <p><strong>Tempo Total (Síncrono):</strong> <span id="metric-sync-time">...</span></p>
                    <p><strong>Chamadas de LLM (Total):</strong> <span id="metric-llm-calls">...</span></p>
                    <p><strong>Tokens de LLM (Total):</strong> <span id="metric-llm-tokens">...</span></p>
                </div>
                <!-- Avaliação -->
                <div id="report-container" class="neo-card bg-blue-200 p-4 space-y-2 hidden">
                    <h3 class="text-lg font-black uppercase text-blue-900">Relatório de Avaliação</h3>
                    <p><strong>Acurácia Geral:</strong> <span id="metric-accuracy">...</span></p>
                    <p><strong>Corretos / Total:</strong> <span id="metric-correct-fields">...</span></p>
                </div>
            </div>

            <!-- Botões de Download -->
            <div class="flex flex-wrap gap-4">
                <button id="download-results-btn" class="neo-button bg-blue-500 text-white">Baixar Dados (JSON)</button>
                <button id="download-report-btn" class="neo-button bg-green-600 text-white hidden">Baixar Relatório (JSON)</button>
                <button id="back-to-main-btn" class="neo-button bg-slate-200 ml-auto">Nova Extração</button>
            </div>

            <!-- Filtro e Visualização de Cards -->
            <div class="pt-6 border-t-4 border-black">
                <div class="mb-4">
                    <label for="filter-input" class="block text-sm font-black uppercase mb-2">Filtrar Resultados</label>
                    <input type="text" id="filter-input" placeholder="Filtrar por nome do PDF..." class="neo-input w-full">
                </div>
                
                <!-- Contentor dos Cards -->
                <div id="results-cards-container" class="space-y-4 max-h-96 overflow-y-auto p-2 bg-slate-100 rounded-lg border-4 border-black">
                    <p class="text-center font-bold">A carregar resultados...</p>
                </div>

                <!-- O container JSON antigo foi removido -->
            </div>

        </div>
    </div>
    
    <!-- MODAL DE AJUDA (NOVO) -->
    <div id="help-modal-backdrop" class="modal-backdrop p-4">
        <div class="neo-card bg-white w-full max-w-xl p-6 space-y-4">
            <div class="flex justify-between items-start border-b-4 border-black pb-3">
                <h3 class="text-2xl font-black uppercase">Como Funciona a Papelada?</h3>
                <button id="close-help-modal-btn" class="neo-button bg-red-500 text-white px-3 py-1 text-sm font-bold">X</button>
            </div>
            
            <div class="space-y-4">
                <p>O sistema Papelada usa uma arquitetura de LLM híbrida para equilibrar **velocidade**, **custo** e **acurácia**.</p>
                
                <h4 class="text-lg font-black uppercase border-b border-black">O que você vê?</h4>
                <ul class="list-disc list-inside space-y-2 text-sm">
                    <li><strong>Extração Síncrona:</strong> O dado é extraído e você avança para a tela de resultados.</li>
                    <li><strong>Processos em Segundo Plano:</strong> A avaliação de acurácia e o aprendizado de regras (LLM) continuam a rodar no backend para atualizar a memória.</li>
                </ul>

                <h4 class="text-lg font-black uppercase border-b border-black">Modos de Execução:</h4>
                <div class="space-y-3">
                    <div class="neo-card p-3 bg-slate-100">
                        <strong class="font-black text-blue-700">Papelzinho (Standard):</strong> Extração mais rápida e barata. Apenas usa regras de memória existentes. Não aprende.
                    </div>
                    <div class="neo-card p-3 bg-blue-200">
                        <strong class="font-black text-blue-700">Papelada (Smart):</strong> Modo padrão. Usa LLM para extrair dados ausentes e aprende novas regras em segundo plano (se houver alta confiança).
                    </div>
                    <div class="neo-card p-3 bg-slate-100">
                        <strong class="font-black text-blue-700">Papelão (Pro):</strong> Modo lento e estratégico. Otimizado para grandes lotes similares. Um documento (Professor) aprende as regras, e os demais (Alunos) as usam imediatamente.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MODAL PARA VISUALIZAÇÃO DOS DADOS -->
    <div id="data-modal-backdrop" class="modal-backdrop p-4">
        <div id="data-modal" class="neo-card bg-white w-full max-w-lg p-6 space-y-4">
            <div class="flex justify-between items-start border-b-4 border-black pb-3">
                <h3 class="text-xl font-black uppercase" id="modal-title">Dados Extraídos</h3>
                <button id="close-modal-btn" class="neo-button bg-red-500 text-white px-3 py-1 text-sm font-bold">X</button>
            </div>
            
            <p class="text-sm"><strong>PDF:</strong> <span id="modal-pdf-name" class="font-normal text-slate-700"></span></p>
            <div id="modal-data-content" class="space-y-3 max-h-80 overflow-y-auto pr-2">
                <!-- Pares Chave: Valor serão inseridos aqui -->
            </div>
            
            <!-- Detalhes de Performance Bruta -->
            <div class="pt-4 border-t-2 border-slate-300">
                <p class="text-xs text-slate-500">Tempo Síncrono: <span id="modal-time-s"></span>s</p>
                <p class="text-xs text-slate-500">Chamadas LLM: <span id="modal-llm-calls"></span></p>
            </div>
        </div>
    </div>

    <!-- SCRIPT -->
    <script>
        // --- Estado Global da Aplicação ---
        
        // --- MUDANÇA: Lógica da API simplificada ---
        // Começa vazio. O usuário DEVE preencher se o localStorage estiver vazio.
        let GLOBAL_PAPELADA_API_KEY = localStorage.getItem('PAPELADA_API_KEY') || '';
        let GLOBAL_OPENAI_API_KEY = localStorage.getItem('OPENAI_API_KEY') || '';
        
        let websocket = null;
        let lastExtractionResults = [];
        let lastEvaluationReport = null;
        let totalFilesToProcess = 0;
        let activeTooltip = null; // Para controlar o tooltip ativo

        // --- Seletores do DOM ---
        const screens = {
            config: document.getElementById('screen-config'),
            main: document.getElementById('screen-main'),
            progress: document.getElementById('screen-progress'),
            results: document.getElementById('screen-results'),
        };
        const messageArea = document.getElementById('message-area');
        
        // Tela de Config
        const papeladaApiKeyInput = document.getElementById('papelada-api-key');
        const openaiApiKeyInput = document.getElementById('openai-api-key');
        const configSaveBtn = document.getElementById('config-save-btn');
        const quickStartBtn = document.getElementById('quick-start-btn');
        const showFullFormBtn = document.getElementById('show-full-form-btn');
        const cancelFullFormBtn = document.getElementById('cancel-full-form-btn');
        const configQuickStart = document.getElementById('config-quick-start');
        const configFullForm = document.getElementById('config-full-form');
        const statusPapeladaKey = document.getElementById('status-papelada-key');
        const statusOpenAIKey = document.getElementById('status-openai-key');
        const logoutBtn = document.getElementById('logout-btn-top');

        // Tela Principal
        const helpBtn = document.getElementById('help-btn');
        const memoryDropdownContainer = document.getElementById('memory-dropdown-container');
        const memoryDropdownBtn = document.getElementById('memory-dropdown-btn');
        const memoryDropdownContent = document.getElementById('memory-dropdown-content');
        const schemaFileInput = document.getElementById('schema-file');
        const pdfFilesInput = document.getElementById('pdf-files');
        const referenceFileInput = document.getElementById('reference-file');
        const extractBtn = document.getElementById('extract-btn');
        const schemaFileName = document.getElementById('schema-file-name');
        const pdfFileNames = document.getElementById('pdf-file-names');
        const referenceFileName = document.getElementById('reference-file-name');
        
        // Botões de Memória (Movidos para o Dropdown)
        const clearMemoryBtn = document.getElementById('clear-memory-btn');
        const downloadMemoryBtn = document.getElementById('download-memory-btn');
        const loadMemoryInput = document.getElementById('load-memory-input');

        // Tela de Progresso
        const progressText = document.getElementById('progress-text');
        const progressBar = document.getElementById('progress-bar');
        const progressLogContainer = document.getElementById('progress-log-container');
        const cancelBtn = document.getElementById('cancel-btn');

        // Tela de Resultados
        const reportContainer = document.getElementById('report-container');
        const metricSyncTime = document.getElementById('metric-sync-time');
        const metricLlmCalls = document.getElementById('metric-llm-calls');
        const metricLlmTokens = document.getElementById('metric-llm-tokens');
        const metricAccuracy = document.getElementById('metric-accuracy');
        const metricCorrectFields = document.getElementById('metric-correct-fields');
        const downloadResultsBtn = document.getElementById('download-results-btn');
        const downloadReportBtn = document.getElementById('download-report-btn');
        const backToMainBtn = document.getElementById('back-to-main-btn');
        const filterInput = document.getElementById('filter-input');
        const resultsCardsContainer = document.getElementById('results-cards-container');

        // Modal Elements
        const dataModalBackdrop = document.getElementById('data-modal-backdrop');
        const closeModalBtn = document.getElementById('close-modal-btn');
        const modalPdfName = document.getElementById('modal-pdf-name');
        const modalDataContent = document.getElementById('modal-data-content');
        const modalTimeS = document.getElementById('modal-time-s');
        const modalLlmCalls = document.getElementById('modal-llm-calls');
        
        // Help Modal Elements
        const helpModalBackdrop = document.getElementById('help-modal-backdrop');
        const closeHelpModalBtn = document.getElementById('close-help-modal-btn');


        const API_URL = "127.0.0.1:8000"; // WebSocket usa URL sem http

        // --- Funções de Navegação e UI ---
        
        function navigateTo(screenId) {
            Object.values(screens).forEach(screen => screen.classList.add('hidden'));
            if (screens[screenId]) {
                screens[screenId].classList.remove('hidden');
            }
            messageArea.classList.add('hidden'); // Limpa mensagens ao navegar
            
            // Fecha todos os modais e dropdowns ao mudar de tela
            dataModalBackdrop.style.display = 'none';
            helpModalBackdrop.style.display = 'none';
            if (memoryDropdownContent) memoryDropdownContent.classList.add('hidden');
            hideModeTooltip();
        }

        function showMessage(message, type = "error") {
            messageArea.textContent = message;
            if (type === "error") {
                messageArea.className = "text-sm p-4 border-4 border-black rounded-lg mb-4 font-bold bg-red-500 text-white";
            } else {
                messageArea.className = "text-sm p-4 border-4 border-black rounded-lg mb-4 font-bold bg-blue-300 text-black";
            }
            messageArea.classList.remove('hidden');
        }

        function logToProgress(message, isError = false) {
            const entry = document.createElement('p');
            if (isError) {
                entry.className = "text-red-400";
                entry.innerHTML = `[ERRO] ${message}`;
            } else {
                entry.innerHTML = `${message}`;
            }
            progressLogContainer.appendChild(entry);
            progressLogContainer.scrollTop = progressLogContainer.scrollHeight;
        }
        
        // --- Lógica de Segurança (Limpeza de API Keys) ---
        
        // Função centralizada para limpar todas as chaves e o estado global
        function cleanupSession() {
            GLOBAL_PAPELADA_API_KEY = '';
            GLOBAL_OPENAI_API_KEY = '';
            localStorage.removeItem('PAPELADA_API_KEY');
            localStorage.removeItem('OPENAI_API_KEY');
            
            if (websocket) {
                websocket.close(1000, "Sessão encerrada");
                websocket = null;
            }
        }
        
        // --- EVENT LISTENER: Alerta ao fechar a janela ---
        window.onbeforeunload = function(e) {
            // Só alerta se houver uma sessão ativa (se as chaves existirem no localStorage)
            if (localStorage.getItem('PAPELADA_API_KEY')) {
                const message = "A sessão será encerrada e as chaves de API removidas ao fechar a janela. Tem certeza?";
                e.returnValue = message; // Padrão para navegadores mais antigos
                return message; // Padrão para navegadores modernos
            }
        };
        
        // --- EVENT LISTENER: Limpar ao fechar a janela (Garantia) ---
        window.onunload = cleanupSession;

        // --- Lógica da Tela de Configuração ---
        
        function renderConfigScreen() {
            // MUDANÇA: Lógica de API simplificada
            if (GLOBAL_PAPELADA_API_KEY) {
                // Se a chave Papelada MANDATÓRIA existir, mostra a tela de início rápido.
                statusPapeladaKey.textContent = 'Configurada';
                statusOpenAIKey.textContent = GLOBAL_OPENAI_API_KEY ? 'Configurada' : 'Ausente (usará .env do servidor)';
                statusOpenAIKey.className = GLOBAL_OPENAI_API_KEY ? 'font-bold text-green-600' : 'font-bold text-slate-500';

                configQuickStart.classList.remove('hidden');
                configFullForm.classList.add('hidden');
                cancelFullFormBtn.classList.add('hidden'); 
            } else {
                // Se a chave estiver faltando, mostra o formulário completo
                papeladaApiKeyInput.value = '';
                openaiApiKeyInput.value = '';
                configQuickStart.classList.add('hidden');
                configFullForm.classList.remove('hidden');
                cancelFullFormBtn.classList.add('hidden'); 
            }
            navigateTo('config');
        }

        // --- Lógica de Inicialização ---
        document.addEventListener('DOMContentLoaded', () => {
            renderConfigScreen();
        });

        // --- Handlers de navegação da Configuração ---

        quickStartBtn.addEventListener('click', () => {
            // Garante que as chaves globais estão corretas antes de avançar
            GLOBAL_PAPELADA_API_KEY = localStorage.getItem('PAPELADA_API_KEY') || '';
            GLOBAL_OPENAI_API_KEY = localStorage.getItem('OPENAI_API_KEY') || '';
            navigateTo('main'); // Inicia a sessão com as chaves salvas
        });
        
        showFullFormBtn.addEventListener('click', () => {
            // Preenche o formulário completo com os valores atuais para edição
            papeladaApiKeyInput.value = GLOBAL_PAPELADA_API_KEY;
            openaiApiKeyInput.value = GLOBAL_OPENAI_API_KEY;
            
            configQuickStart.classList.add('hidden');
            configFullForm.classList.remove('hidden');
            cancelFullFormBtn.classList.remove('hidden'); // Permite cancelar se já houver chaves
        });
        
        cancelFullFormBtn.addEventListener('click', () => {
            // Volta para a tela de início rápido com as chaves salvas
            renderConfigScreen();
        });

        configSaveBtn.addEventListener('click', () => {
            const papeladaKey = papeladaApiKeyInput.value.trim();
            const openaiKey = openaiApiKeyInput.value.trim();

            if (!papeladaKey) {
                showMessage("A Papelada API Key é obrigatória para salvar.", "error");
                return;
            }
            
            GLOBAL_PAPELADA_API_KEY = papeladaKey;
            GLOBAL_OPENAI_API_KEY = openaiKey;
            localStorage.setItem('PAPELADA_API_KEY', papeladaKey);
            localStorage.setItem('OPENAI_API_KEY', openaiKey);
            
            showMessage("Chaves de API salvas com sucesso!", "success");
            navigateTo('main');
        });

        // --- MUDANÇA: Lógica de Logout Atualizada ---
        const handleLogout = async () => {
            if (confirm("Tem certeza que deseja encerrar a sessão? Suas chaves de API locais e a memória do SERVIDOR serão removidas.")) {
                
                const keyToUseForDeletion = GLOBAL_PAPELADA_API_KEY; // Salva a chave atual
                
                // 1. Limpa a sessão local (chaves)
                cleanupSession(); // Limpa as chaves globais e localStorage
                
                // 2. Tenta limpar a memória do servidor com a chave que acabamos de salvar
                if (keyToUseForDeletion) { 
                     try {
                         const response = await fetch(`http://${API_URL}/memory/`, {
                             method: 'DELETE',
                             headers: { 'X-API-Key': keyToUseForDeletion }
                         });
                         if(response.ok) {
                             console.log("Memória do servidor limpa.");
                         } else {
                             console.error("Falha ao limpar a memória do servidor, mas a sessão local foi encerrada.");
                         }
                     } catch (err) {
                         console.error("Erro de rede ao limpar a memória do servidor:", err);
                     }
                }

                // 3. Volta para a tela de config
                renderConfigScreen();
            }
        };

        // Associa o handler ao botão de logout
        logoutBtn.addEventListener('click', handleLogout); 
        
        // --- Handlers do Dropdown Memória ---
        if (memoryDropdownBtn) {
            memoryDropdownBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Impede que o clique feche imediatamente
                memoryDropdownContent.classList.toggle('hidden');
            });

            // Fecha o dropdown se clicar fora dele
            document.addEventListener('click', (e) => {
                if (memoryDropdownContainer && !memoryDropdownContainer.contains(e.target)) {
                    memoryDropdownContent.classList.add('hidden');
                }
            });
        }


        // --- Lógica do Tooltip de Modo ---
        
        function showModeTooltip(mode, element) {
            hideModeTooltip(); // Esconde o anterior
            
            const tooltip = document.getElementById(`tooltip-${mode}`);
            if (tooltip) {
                // Posiciona o tooltip
                const rect = element.getBoundingClientRect();
                const containerRect = screens.main.getBoundingClientRect();

                // Garante que o tooltip aparece sobre o botão "?"
                tooltip.style.top = `${rect.bottom - containerRect.top + 5}px`;
                tooltip.style.left = `${rect.left - containerRect.left + (rect.width / 2)}px`;

                // Centraliza horizontalmente e torna visível
                tooltip.style.transform = 'translateX(-50%)';
                tooltip.classList.add('visible');
                activeTooltip = tooltip;
            }
        }
        
        function hideModeTooltip() {
            if (activeTooltip) {
                activeTooltip.classList.remove('visible');
                activeTooltip = null;
            }
        }

        // Adiciona listeners aos botões (?) e ao mouseleave
        document.querySelectorAll('.mode-help-btn').forEach(btn => {
            const mode = btn.getAttribute('data-mode');
            
            // Mouse Enter (Hover)
            btn.addEventListener('mouseenter', () => {
                showModeTooltip(mode, btn);
            });
            
            // Mouse Leave
            btn.addEventListener('mouseleave', () => {
                // Delay para dar tempo de mover para o tooltip
                setTimeout(hideModeTooltip, 100); 
            });

            // Click (para fixar/alternar se o usuário estiver em um dispositivo touch ou quiser clicar)
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (activeTooltip && activeTooltip.id === `tooltip-${mode}`) {
                    hideModeTooltip();
                } else {
                    showModeTooltip(mode, btn);
                }
            });
        });
        
        // Adiciona listeners para fechar o tooltip ao clicar em qualquer lugar
        document.addEventListener('click', (e) => {
            if (activeTooltip && !e.target.classList.contains('mode-help-btn') && !e.target.closest('.mode-tooltip')) {
                hideModeTooltip();
            }
        });

        // --- Lógica da Tela Principal (Upload) ---

        // Feedback de ficheiros
        schemaFileInput.addEventListener('change', () => {
            if (schemaFileInput.files.length > 0) {
                schemaFileName.textContent = schemaFileInput.files[0].name;
            } else {
                schemaFileName.textContent = '';
            }
        });
        pdfFilesInput.addEventListener('change', () => {
            if (pdfFilesInput.files.length > 0) {
                pdfFileNames.textContent = `${pdfFilesInput.files.length} PDF(s) selecionados.`;
            } else {
                pdfFileNames.textContent = '';
            }
        });
        referenceFileInput.addEventListener('change', () => {
            if (referenceFileInput.files.length > 0) {
                referenceFileName.textContent = referenceFileInput.files[0].name;
            } else {
                referenceFileName.textContent = '';
            }
        });
        
        // --- LÓGICA DE SUBMISSÃO (WEBSOCKET) ---
        
        extractBtn.addEventListener('click', async () => {
            const schemaFile = schemaFileInput.files[0];
            const pdfFiles = pdfFilesInput.files;
            const referenceFile = referenceFileInput.files[0];
            const selectedMode = document.querySelector('input[name="execution-mode"]:checked').value;

            // 1. Validação (Usa GLOBAL_PAPELADA_API_KEY que deve estar preenchida)
            if (!GLOBAL_PAPELADA_API_KEY || !schemaFile || pdfFiles.length === 0) {
                showMessage("A Papelada API Key deve ser configurada, e você deve selecionar um schema e pelo menos um PDF.", "error");
                return;
            }
            
            // 2. Resetar estado e ir para tela de progresso
            lastExtractionResults = [];
            lastEvaluationReport = null;
            totalFilesToProcess = 0; 
            
            try {
                // Para calcular o total de arquivos a processar (totalFilesToProcess)
                const schemaContent = await schemaFile.text();
                const schemaJson = JSON.parse(schemaContent);
                totalFilesToProcess = Array.isArray(schemaJson) ? schemaJson.length : 0;
            } catch(e) {
                showMessage("Erro ao ler o ficheiro de schema. É um JSON válido?", "error");
                return;
            }
            
            progressBar.style.width = '0%';
            progressText.textContent = `Processando 0 / ${totalFilesToProcess} arquivos...`;
            progressLogContainer.innerHTML = '<p class="text-neutral-500">A iniciar conexão WebSocket...</p>';
            navigateTo('progress');

            // 3. Iniciar Conexão WebSocket
            if (websocket) { websocket.close(); }
            websocket = new WebSocket(`ws://${API_URL}/ws/extract_live/`);

            // 4. Definir Handlers do WebSocket
            
            websocket.onopen = async () => {
                logToProgress("Conexão estabelecida. A ler e enviar ficheiros...");
                
                try {
                    // Ler todos os ficheiros como Base64
                    const schemaB64 = await readFileAsBase64(schemaFile);
                    const pdfsB64 = await Promise.all(
                        Array.from(pdfFiles).map(file => readFileAsBase64(file))
                    );
                    let refB64 = null;
                    if (referenceFile) {
                        refB64 = await readFileAsBase64(referenceFile);
                    }

                    // Enviar a mensagem de configuração
                    const configMessage = {
                        papelada_api_key: GLOBAL_PAPELADA_API_KEY,
                        openai_api_key: GLOBAL_OPENAI_API_KEY, 
                        mode: selectedMode,
                        schema_file: { name: schemaFile.name, content: schemaB64.content },
                        pdf_files: pdfsB64.map((pdf, i) => ({ name: pdfFiles[i].name, content: pdf.content })),
                        reference_file: refB64 ? { name: referenceFile.name, content: refB64.content } : null
                    };
                    
                    websocket.send(JSON.stringify(configMessage));
                    logToProgress("Ficheiros enviados. A aguardar processamento do backend...");
                    
                } catch (err) {
                    logToProgress(`Erro ao ler ficheiros: ${err.message}`, true);
                    websocket.close();
                }
            };
            
            websocket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                switch(data.type) {
                    case 'status':
                        logToProgress(`[BACKEND] ${data.message}`);
                        break;
                    
                    case 'progress':
                        const result = data.result;
                        lastExtractionResults.push(result);
                        
                        const percent = (lastExtractionResults.length / totalFilesToProcess) * 100;
                        progressBar.style.width = `${percent > 100 ? 100 : percent}%`;
                        progressText.textContent = `Processando ${lastExtractionResults.length} / ${totalFilesToProcess} arquivos...`;
                        
                        // Determina a cor do texto do log (Verde para Regra, Amarelo para LLM)
                        const llmCalls = (result.metrics?.llm_data_calls || 0);
                        const logColor = llmCalls > 0 ? 'text-yellow-400' : 'text-green-400';
                        const sourceText = llmCalls > 0 ? 'usando LLM' : 'usando Regra (Cache)';

                        logToProgress(`[OK] <span class="text-white">${result.pdf_path}</span> processado em <span class="${logColor}">${result.sync_data_time_s}s</span> <span class="text-slate-500">(${sourceText})</span>`);
                        break;
                    
                    case 'extraction_complete':
                        logToProgress("Extração concluída! A carregar tela de resultados...");
                        lastExtractionResults = data.results; 
                        processResults(); 
                        navigateTo('results');
                        break;
                        
                    case 'evaluation_complete':
                        logToProgress("Relatório de avaliação recebido.");
                        lastEvaluationReport = data.evaluation_report;
                        updateEvaluationUI(lastEvaluationReport); 
                        break;
                        
                    case 'learning_complete':
                        logToProgress("Aprendizado em segundo plano concluído. Memória salva.");
                        showMessage("Aprendizado em segundo plano concluído. Memória atualizada.", "success");
                        break;
                        
                    case 'all_processes_complete':
                        logToProgress("Todos os processos do servidor concluídos.");
                        websocket.close(1000, "Trabalho concluído");
                        break;
                        
                    case 'error':
                        logToProgress(data.message, true);
                        showMessage(data.message, "error");
                        navigateTo('main'); 
                        if (websocket) websocket.close();
                        break;
                }
            };
            
            websocket.onerror = () => {
                logToProgress("Erro na conexão WebSocket. Verifique se o servidor está a rodar.", true);
                showMessage("Erro na conexão WebSocket.", "error");
                navigateTo('main');
            };
            
            websocket.onclose = (event) => {
                logToProgress(`Conexão WebSocket fechada (Cód: ${event.code}).`);
                websocket = null;
            };
        });
        
        // Função auxiliar para ler ficheiros como Base64
        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve({ name: file.name, content: reader.result });
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(file); // Retorna base64 com Data-URL
            });
        }


        // --- Lógica da Tela de Progresso ---
        cancelBtn.addEventListener('click', () => {
            if (websocket) {
                websocket.close(1000, "Cancelado pelo usuário"); // 1000 = Normal Closure
                navigateTo('main');
            }
        });

        // --- Lógica da Tela de Resultados ---
        
        function processResults() {
            resultsCardsContainer.innerHTML = '';
            filterInput.value = '';

            reportContainer.classList.add('hidden');
            downloadReportBtn.classList.add('hidden');
            modalDataContent.textContent = ''; // Limpa conteúdo do modal
            dataModalBackdrop.style.display = 'none'; // Garante que o modal está fechado

            metricAccuracy.textContent = 'Aguardando...';
            metricCorrectFields.textContent = '...';

            let totalSyncTime = 0;
            let totalCalls = 0;
            let totalTokens = 0;

            lastExtractionResults.forEach(res => {
                totalSyncTime += res.sync_data_time_s || 0;
                totalCalls += (res.metrics?.llm_data_calls || 0) + (res.metrics?.llm_regex_calls || 0);
                totalTokens += (res.metrics?.llm_data_tokens || 0) + (res.metrics?.llm_regex_tokens || 0);
            });

            metricSyncTime.textContent = `${totalSyncTime.toFixed(3)}s`;
            metricLlmCalls.textContent = totalCalls;
            metricLlmTokens.textContent = totalTokens;
            
            renderResultCards(lastExtractionResults);
        }
        
        function updateEvaluationUI(report) {
            if (!report || report.error) {
                metricAccuracy.textContent = 'Falhou';
                metricCorrectFields.textContent = 'Erro ao gerar';
                reportContainer.classList.remove('hidden'); 
                downloadReportBtn.classList.add('hidden');
                return;
            }
            const summary = report.accuracy_summary;
            metricAccuracy.textContent = summary.overall_accuracy;
            metricCorrectFields.textContent = `${summary.correct_fields} / ${summary.total_fields}`;
            reportContainer.classList.remove('hidden');
            downloadReportBtn.classList.remove('hidden');
        }
        
        // --- Função para Abrir Modal ---
        function showExtractionModal(index) {
            const result = lastExtractionResults[index];
            const data = result.extracted_data || {};
            const metrics = result.metrics || {};
            
            modalPdfName.textContent = result.pdf_path;
            modalTimeS.textContent = result.sync_data_time_s?.toFixed(3) || 'N/A';
            modalLlmCalls.textContent = (metrics.llm_data_calls + metrics.llm_regex_calls) || 0;
            
            modalDataContent.innerHTML = ''; // Limpa conteúdo
            
            for (const [key, value] of Object.entries(data)) {
                const isNull = value === 'null' || value === null || value === undefined;
                
                const dataEntry = document.createElement('div');
                dataEntry.className = 'neo-card p-3 bg-white';
                dataEntry.innerHTML = `
                    <p class="text-xs text-slate-500 font-bold uppercase truncate">${key}:</p>
                    <p class="text-base font-black ${isNull ? 'text-red-500' : 'text-gray-800'} break-words">${isNull ? 'NÃO ENCONTRADO' : value}</p>
                `;
                modalDataContent.appendChild(dataEntry);
            }

            dataModalBackdrop.style.display = 'flex';
        }

        // --- Correção: Renderização dos Cards e Event Listener ---
        function renderResultCards(results) {
            resultsCardsContainer.innerHTML = ''; 
            
            if (results.length === 0) {
                 resultsCardsContainer.innerHTML = '<p class="text-center font-bold">Nenhum dado extraído.</p>';
                 return;
            }

            const filterText = filterInput.value.toLowerCase();
            
            results.forEach((result, index) => {
                const pdfName = result.pdf_path;
                
                if (filterText && !pdfName.toLowerCase().includes(filterText)) {
                    return; 
                }

                const card = document.createElement('div');
                card.className = 'neo-card flex justify-between items-center p-4 cursor-pointer hover:bg-slate-50 transition-colors';
                card.innerHTML = `
                    <div>
                        <strong class="text-blue-700 text-lg">${pdfName}</strong>
                        <p class="text-sm text-gray-600 font-bold">Label: ${result.label} | Tempo: ${result.sync_data_time_s}s</p>
                    </div>
                    <button class="neo-button bg-gray-800 text-white text-sm py-2 px-4" data-index="${index}">
                        Ver Dados
                    </button>
                `;
                
                const viewButton = card.querySelector('button');
                viewButton.addEventListener('click', () => {
                    showExtractionModal(index);
                });
                
                resultsCardsContainer.appendChild(card);
            });
        }
        
        filterInput.addEventListener('input', () => {
            renderResultCards(lastExtractionResults);
        });
        
        // --- Handlers dos Modais ---
        closeModalBtn.addEventListener('click', () => {
            dataModalBackdrop.style.display = 'none';
        });
        // Fecha o modal de dados se clicar fora dele
        dataModalBackdrop.addEventListener('click', (e) => {
            if (e.target === dataModalBackdrop) {
                dataModalBackdrop.style.display = 'none';
            }
        });
        
        helpBtn.addEventListener('click', () => {
            helpModalBackdrop.style.display = 'flex';
        });
        
        closeHelpModalBtn.addEventListener('click', () => {
            helpModalBackdrop.style.display = 'none';
        });
        // Fecha o modal de ajuda se clicar fora dele
        helpModalBackdrop.addEventListener('click', (e) => {
            if (e.target === helpModalBackdrop) {
                helpModalBackdrop.style.display = 'none';
            }
        });


        // --- Funções de Download e Navegação (Inalteradas) ---

        function downloadJSON(data, filename) {
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        downloadResultsBtn.addEventListener('click', () => {
            downloadJSON(lastExtractionResults, 'extraction_results.json');
        });
        
        downloadReportBtn.addEventListener('click', () => {
            downloadJSON(lastEvaluationReport, 'evaluation_report.json');
        });

        backToMainBtn.addEventListener('click', () => {
            schemaFileInput.value = null;
            pdfFilesInput.value = null;
            referenceFileInput.value = null;
            schemaFileName.textContent = '';
            pdfFileNames.textContent = '';
            referenceFileName.textContent = '';
            
            navigateTo('main');
        });


        // --- Lógica de Gerenciamento de Memória (HTTP) ---

        async function makeApiCall(url, method, body = null, isJson = false) {
            try {
                // Usa a Papelada Key salva no estado global para o header
                const options = {
                    method: method,
                    headers: { 'X-API-Key': GLOBAL_PAPELADA_API_KEY },
                };
                if (body) {
                    options.body = body;
                    if (isJson) {
                         options.headers['Content-Type'] = 'application/json';
                    }
                }
                
                const response = await fetch(url, options);
                
                if (!response.ok) {
                    const err = await response.json();
                    throw new Error(err.detail || `Erro ${response.status}`);
                }

                if (url.includes('/download/')) {
                    const blob = await response.blob();
                    const downloadUrl = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = "memory.json";
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    window.URL.revokeObjectURL(downloadUrl);
                    return { message: "Memória baixada com sucesso." };
                }

                return await response.json();
                
            } catch (error) {
                console.error(`Falha na API [${method} ${url}]:`, error);
                showMessage(`Erro: ${error.message}`, "error");
                return null;
            }
        }
        
        clearMemoryBtn.addEventListener('click', async () => {
            if (confirm("Tem certeza que deseja apagar TODA a memória de regex? Esta ação é irreversível.")) {
                const result = await makeApiCall(`http://${API_URL}/memory/`, 'DELETE');
                if (result) {
                    showMessage("Memória limpa com sucesso!", "success");
                }
            }
            memoryDropdownContent.classList.add('hidden');
        });
        
        downloadMemoryBtn.addEventListener('click', async () => {
             const result = await makeApiCall(`http://${API_URL}/memory/download/`, 'GET');
             if(result) {
                 showMessage(result.message, "success");
             }
             memoryDropdownContent.classList.add('hidden');
        });
        
        loadMemoryInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            if (confirm(`Tem certeza que deseja substituir a memória atual pelo ficheiro '${file.name}'?`)) {
                const formData = new FormData();
                formData.append("memory_file", file);
                
                const result = await makeApiCall(`http://${API_URL}/memory/upload/`, 'POST', formData);
                if (result) {
                    showMessage(result.message, "success");
                }
            }
            e.target.value = null; 
            memoryDropdownContent.classList.add('hidden');
        });

    </script>
</body>
</html>